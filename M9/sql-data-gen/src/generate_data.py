import shutil
from faker import Faker
import random
from datetime import datetime, timedelta
from decimal import Decimal

# Data generation configuration
CONFIG = {
    "num_categories": 20,
    "num_products": 10000,
    "num_orders": 3000,
    "max_items_per_order": 5,
    "num_shipments": 3000,  # Not every order is shipped immediately
    "max_quantity_per_item": 5,
}

# Initial static data
STATIC_CATEGORIES = [
    ("Electronics", "Devices powered by electricity, including computing and audio equipment."),
    ("Books", "Printed or digital published works."),
    ("Home Appliances", "Machines designed to perform household functions."),
    ("Apparel", "Clothing and fashion accessories."),
    ("Sporting Goods", "Equipment and clothing for sports and outdoor activities."),
    ("Toys and Games", "Items for play, amusement, and entertainment."),
    ("Groceries", "Food and other edible consumables."),
    ("Health & Beauty", "Personal care products, cosmetics, and wellness items."),
    ("Automotive", "Vehicle parts, accessories, and car care products."),
    ("Pet Supplies", "Food, toys, and accessories for pets."),
    ("Garden & Outdoor", "Plants, tools, and equipment for gardening and outdoor living."),
    ("Office Supplies", "Stationery, equipment, and materials for work and study."),
]

# Initialization
fake = Faker('en_US')
timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
OUTPUT_FILE = f"output/init-db-{timestamp}.sql"
STD_OUTPUT_FILE = "output/init-db.sql"

# Lists to store generated IDs for foreign key lookups
category_ids = [] # Stores category_id
product_data = [] # Stores (product_id, price)
order_ids = [] # Stores order_id
order_item_id_counter = 1
shipment_id_counter = 1

def generate_sql_header(config):
    """Generates the file header with configuration."""
    now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    header = f"-- SCRIPT AUTOMATICALLY GENERATED BY src/generate_data.py (on {now})\n"
    header += f"-- Number of generated categories: {config['num_categories']}\n"
    header += f"-- Number of generated products: {config['num_products']}\n"
    header += f"-- Number of generated orders: {config['num_orders']}\n"
    header += f"-- Number of generated shipments: {config['num_shipments']}\n"
    header += "\n"
    return header

def generate_categories():
    """Generates DDL and DML for categories, and populates category_ids list."""
    ddl = "\n-- 1. Categories Table\n"
    ddl += """
DROP TABLE IF EXISTS categories;
CREATE TABLE categories (
  category_id SERIAL PRIMARY KEY,
  name VARCHAR(100) NOT NULL UNIQUE,
  description TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);
"""
    
    dml = ""
    # Static data inserts
    dml += "\n-- Static data for categories\n"
    static_inserts = []
    for i, (name, desc) in enumerate(STATIC_CATEGORIES, 1):
        static_inserts.append(f"({i}, '{name.replace("'", "''")}', '{desc.replace("'", "''")}')")
        category_ids.append(i)
    
    dml += "INSERT INTO categories (category_id, name, description) VALUES\n"
    dml += ",\n".join(static_inserts) + ";\n"

    # Dynamic data generation
    dml += "\n-- Dynamically generated categories\n"
    dynamic_inserts = []
    for i in range(len(STATIC_CATEGORIES) + 1, CONFIG["num_categories"] + 1):
        name = fake.unique.word().capitalize()
        desc = fake.sentence(nb_words=10).replace("'", "''")
        dynamic_inserts.append(f"({i}, '{name}', '{desc}')")
        category_ids.append(i)

    if dynamic_inserts:
        dml += "INSERT INTO categories (category_id, name, description) VALUES\n"
        dml += ",\n".join(dynamic_inserts) + ";\n"
    
    return ddl, dml

def generate_products():
    """Generates DDL and DML for products, using category_ids, and populates product_data list."""
    ddl = "\n-- 2. Products Table\n"
    ddl += f"""
DROP TABLE IF EXISTS products;
CREATE TABLE products (
  product_id SERIAL PRIMARY KEY,
  name VARCHAR(100) NOT NULL,
  description TEXT,
  price DECIMAL(10, 2) NOT NULL,
  stock INT NOT NULL DEFAULT 0,
  category_id INT REFERENCES categories (category_id), -- Foreign key
  sku VARCHAR(50) UNIQUE NOT NULL,
  weight_g INT,
  is_active BOOLEAN NOT NULL DEFAULT TRUE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);
"""
    dml = "\n-- Generating products\n"
    
    products_to_generate = []
    
    for product_id in range(1, CONFIG["num_products"] + 1):
        cat_id = random.choice(category_ids)
        name = fake.catch_phrase()
        desc = fake.text(max_nb_chars=200).replace("\n", " ").replace("'", "''")
        price = Decimal(random.randint(1, 10000) / 100).quantize(Decimal('0.01'))
        stock = random.randint(0, 500)
        sku = fake.unique.bothify(text='???-####-???').upper()
        weight_g = random.randint(50, 5000)
        is_active = fake.boolean(chance_of_getting_true=95)
        
        products_to_generate.append(
            f"({product_id}, '{name}', '{desc}', {price}, {stock}, {cat_id}, '{sku}', {weight_g}, {str(is_active).upper()})"
        )
        product_data.append((product_id, price)) 

    values_str = ",\n".join(products_to_generate)
    dml += f"""
INSERT INTO products 
    (product_id, name, description, price, stock, category_id, sku, weight_g, is_active) 
VALUES
{values_str};
"""
    return ddl, dml

def generate_orders():
    """Generates DDL and DML for orders and populates order_ids list."""
    ddl = "\n-- 3. Orders Table\n"
    ddl += """
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (
  order_id SERIAL PRIMARY KEY,
  customer_name VARCHAR(150) NOT NULL,
  customer_email VARCHAR(150),
  shipping_address TEXT NOT NULL,
  billing_address TEXT,
  order_date TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  total_amount DECIMAL(10, 2) NOT NULL,
  status VARCHAR(20) NOT NULL DEFAULT 'Pending', -- (Pending, Processing, Shipped, Delivered, Cancelled)
  payment_method VARCHAR(50),
  notes TEXT
);
"""
    dml = "\n-- Generating orders\n"

    statuses = ['Pending', 'Processing', 'Shipped', 'Delivered', 'Cancelled']
    payment_methods = ['Credit Card', 'Bank Transfer', 'PayPal', 'Cash on Delivery']
    
    orders_to_generate = []
    
    for order_id in range(1, CONFIG["num_orders"] + 1):
        order_ids.append(order_id)
        
        customer_name = fake.name().replace("'", "''")
        customer_email = fake.email()
        address = fake.address().replace("\n", ", ").replace("'", "''")
        billing_address = address if fake.boolean(chance_of_getting_true=80) else fake.address().replace("\n", ", ").replace("'", "''")
        order_date = fake.date_time_this_year(before_now=True, after_now=False).isoformat()
        status = random.choice(statuses)
        payment_method = random.choice(payment_methods)
        
        orders_to_generate.append(
            f"({order_id}, '{customer_name}', '{customer_email}', '{address}', '{billing_address}', '{order_date}', 0.00, '{status}', '{payment_method}')"
        )
        
    values_str = ",\n".join(orders_to_generate)
    dml += f"""
INSERT INTO orders 
    (order_id, customer_name, customer_email, shipping_address, billing_address, order_date, total_amount, status, payment_method) 
VALUES
{values_str};
"""
    return ddl, dml

def generate_order_items():
    """
    Generates DDL and DML for order_items.
    Calculates total_amount for each order and includes UPDATE statements in the DML part.
    """
    global order_item_id_counter
    ddl = "\n-- 4. Order_Items Table\n"
    ddl += """
DROP TABLE IF EXISTS order_items;
CREATE TABLE order_items (
  item_id SERIAL PRIMARY KEY,
  order_id INT REFERENCES orders (order_id) ON DELETE CASCADE,
  product_id INT REFERENCES products (product_id),
  quantity INT NOT NULL,
  price_at_purchase DECIMAL(10, 2) NOT NULL,
  CONSTRAINT unique_order_product UNIQUE (order_id, product_id)
);
"""
    dml = "\n-- Generating order items\n"
    
    items_to_generate = []
    order_totals = {order_id: Decimal('0.00') for order_id in order_ids}
    
    product_price_map = {id: price for id, price in product_data}

    for order_id in order_ids:
        num_items = random.randint(1, CONFIG["max_items_per_order"])
        
        try:
            selected_products = random.sample(product_data, num_items)
        except ValueError:
             selected_products = random.sample(product_data, len(product_data))
        
        order_total = Decimal('0.00')
        
        for product_id, price in selected_products:
            quantity = random.randint(1, CONFIG["max_quantity_per_item"])
            item_price = product_price_map.get(product_id, price)
            subtotal = item_price * quantity
            order_total += subtotal
            
            items_to_generate.append(
                f"({order_item_id_counter}, {order_id}, {product_id}, {quantity}, {item_price})"
            )
            order_item_id_counter += 1
        
        order_totals[order_id] = order_total.quantize(Decimal('0.01'))

    values_str = ",\n".join(items_to_generate)
    dml += f"""
INSERT INTO order_items 
    (item_id, order_id, product_id, quantity, price_at_purchase) 
VALUES
{values_str};
"""

    dml += "\n-- Updating total_amount in Orders after generating Order_Items\n"
    for order_id, total in order_totals.items():
        if total > 0:
            dml += f"UPDATE orders SET total_amount = {total} WHERE order_id = {order_id};\n"

    return ddl, dml, order_totals

def generate_shipments(order_totals):
    """Generates DDL and DML for shipments."""
    global shipment_id_counter
    ddl = "\n-- 5. Shipments Table\n"
    ddl += """
CREATE TABLE shipments (
  shipment_id SERIAL PRIMARY KEY,
  order_id INT REFERENCES orders (order_id) ON DELETE CASCADE,
  shipping_carrier VARCHAR(100) NOT NULL,
  tracking_number VARCHAR(100) UNIQUE NOT NULL,
  shipment_date TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  delivery_date TIMESTAMP WITH TIME ZONE,
  shipment_cost DECIMAL(6, 2) DEFAULT 0.00,
  status VARCHAR(20) NOT NULL DEFAULT 'In Transit'
);
"""
    dml = "\n-- Generating shipments\n"

    carriers = ['DHL', 'FedEx', 'UPS', 'InPost', 'Poczta Polska'] # 'Poczta Polska' is kept in English as a literal carrier name, like InPost
    shipment_statuses = ['In Transit', 'Delivered', 'Exception', 'Ready for Pickup']
    shipped_orders = [order_id for order_id, total in order_totals.items() if total > 0]
    
    orders_with_shipment = random.sample(shipped_orders, min(CONFIG["num_shipments"], len(shipped_orders)))
    
    shipments_to_generate = []
    
    for order_id in orders_with_shipment:
        carrier = random.choice(carriers)
        tracking_number = fake.unique.bothify(text='??########??').upper()
        status = random.choice(shipment_statuses)
        delivery_date = None
        
        shipment_date_obj = fake.date_time_between(start_date="-1y", end_date="now")

        if status == 'Delivered':
            delivery_date = fake.date_time_between(start_date=shipment_date_obj, end_date="now")
        
        shipment_date = shipment_date_obj.isoformat()
        delivery_date_iso = delivery_date.isoformat() if delivery_date else None
        shipment_cost = Decimal(random.randint(500, 3000) / 100).quantize(Decimal('0.01'))
        
        shipments_to_generate.append(
            f"({shipment_id_counter}, {order_id}, '{carrier}', '{tracking_number}', '{shipment_date}', {f"'{delivery_date_iso}'" if delivery_date_iso else 'NULL'}, {shipment_cost}, '{status}')"
        )
        shipment_id_counter += 1

    if shipments_to_generate:
        values_str = ",\n".join(shipments_to_generate)
        dml += f"""
INSERT INTO shipments 
    (shipment_id, order_id, shipping_carrier, tracking_number, shipment_date, delivery_date, shipment_cost, status) 
VALUES
{values_str};
"""
    else:
        dml += "-- No Shipments records generated\n"
        
    return ddl, dml

def main():
    """Main function to orchestrate the data generation."""
    try:
        # --- Data generation logic. The order of calls is important due to data dependencies. ---
        
        # 1. Generate categories data
        categories_ddl, categories_dml = generate_categories()
        
        # 2. Generate products data (depends on categories)
        products_ddl, products_dml = generate_products()
        
        # 3. Generate orders data
        orders_ddl, orders_dml = generate_orders()
        
        # 4. Generate order items data (depends on orders and products)
        order_items_ddl, order_items_dml, order_totals = generate_order_items()
        
        # 5. Generate shipments data (depends on orders)
        shipments_ddl, shipments_dml = generate_shipments(order_totals)

        with open(OUTPUT_FILE, 'w', encoding='utf-8') as f:
            # File Header
            f.write(generate_sql_header(CONFIG))
            
            # --- DDL Section (Data Definition Language) ---
            f.write("\n-- ##################################################\n")
            f.write("-- ##      DDL SECTION - CREATING DATABASE STRUCTURE ##\n")
            f.write("-- ##################################################\n")
            f.write(categories_ddl)
            f.write(products_ddl)
            f.write(orders_ddl)
            f.write(order_items_ddl)
            f.write(shipments_ddl)
            
            # --- DML Section (Data Manipulation Language) ---
            f.write("\n-- ##################################################\n")
            f.write("-- ##      DML SECTION - INSERTING DATA          ##\n")
            f.write("-- ##################################################\n")
            f.write(categories_dml)
            f.write(products_dml)
            f.write(orders_dml)
            f.write(order_items_dml)
            f.write(shipments_dml)
            
            f.write(f"SELECT setval(pg_get_serial_sequence('products', 'product_id'), (SELECT MAX(product_id) FROM products));\n")
        
        print(f"ðŸŽ‰ Success!")
        print(f"ðŸŽ‰ SQL file ./{OUTPUT_FILE} has been generated with {CONFIG['num_products']} products and {len(order_totals)} orders.")
        
        # copy the output file to the standard output file
        shutil.copy(OUTPUT_FILE, STD_OUTPUT_FILE)
        print(f"ðŸŽ‰ SQL file ./{STD_OUTPUT_FILE} has been copied from ./{OUTPUT_FILE}.")

    except Exception as e:
        print(f"An error occurred: {e}")

if __name__ == "__main__":
    main()